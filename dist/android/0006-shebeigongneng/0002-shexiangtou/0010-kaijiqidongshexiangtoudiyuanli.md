主要看cpu的lcd控制器支不支持多图层的显示，我调试过telechips 8902，8902的lcd控制器有三个通道，系统ui只会占用其中的一个通道，其他两个通道是屏蔽的，如果你想开机启动摄像头，那么就得开放剩下的两个通道中的一个，将你的摄像头图像输出的缓冲区映射到该通道的缓冲区，这样摄像头的图像就会输出到lcd显示出来，如果你同时打开两个通道，那得到的结果是重叠的显示；这个原理应用在车载导航中的后视摄像（也就是倒车）比较多，用户不可能等到你的设备开机进入系统后才开始倒车，而是车子启动，用户一挂倒车档，导航设备就会马上从开机界面切换到后视摄像头的画面，现在的导航设备基本上到是这样的了。
摘自boot里面的一个小框架，算不上一个例子，这玩意不像应用那样给你写个例子，底层的代码还存在平台的差异，不过原理思路应该差不多
```  
public class Snippet {
	void RearCam_IsrProc(void)
	{
        PLCDC pLCDC = (PLCDC)&HwLCDC1_BASE;
        //只是个IO口的检测，用来判断是否在倒档状态，如果是就启动摄像头，否则就显示正常的开机logo
        if(RearCamDev_IsRearMode())
        {
            if(pLCDC->LI2P == 0x10)
            {
                RearCam_LcdToRearMode(TRUE, FALSE);
            }
        }
        else
        {
            if(pLCDC->LI2P == 0x00)
            {
            	RearCam_LcdToRearMode(FALSE, FALSE);
            }
        }
	}
}
```
boot跑完后，上面的工作交给内核来完成。
当初调试的是wince的系统，分三步来完成，开始是boot里面，接着进入oal里面，最后由驱动的线程去完成，而且系统跑起来后就由驱动的线程去完成了。
在android下没调过，不过已经有人调出来了，在android下怎么做我也很想知道。但是不管怎么做，最终还是得有个检测的东东在那里，就像上述的代码那样。