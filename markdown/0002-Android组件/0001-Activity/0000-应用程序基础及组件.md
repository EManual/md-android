#### 引言
为了后面的例子做准备，本篇及接下来几篇将介绍Android应用程序的原理及术语，这些也是作为一个Android的开发人员必须要了解，且深刻理解的东西。本篇的主题如下：
```  
1、应用程序基础
2、应用程序组件
2.1、活动（Activities）
2.2、服务（Services）
2.3、广播接收者（Broadcast receivers）
2.4、内容提供者（Content providers）
```
#### 1、应用程序基础
Android应用程序是用Java编程语言写的。编译后的Java代码——包括应用程序要求的任何数据和资源文件，通过aapt工具捆绑成一个Android包，归档文件以.apk为后缀。这个文件是分发应用程序和安装到移动设备的中介或工具，用户下载这个文件到他们的设备上。一个.apk文件中的所有代码被认为是一个应用程序。
#### aapt：
aapt是Android Asset Packaging Tool的首字母缩写，这个工具包含在SDK的tools/目录下。查看、创建、更新与zip兼容的归档文件（zip、jar、apk）。它也能将资源文件编译成二进制包。
尽管你可能不会经常直接使用appt，但是构建脚本（build scripts）和IDE插件会使用这个工具打包apk文件，构成一个Android应用程序。
如需更详细的使用细节，打开一个终端，进入tools/目录下，运行命令：
1) Linux或Mac操作系统：./aapt
2) Windows：aapt.exe
注意：tools/目录是指android SDK目录下的/platforms/android-X/tools/
在许多方面，每个Android应用程序生活在它自己的世界：
默认情况下，每一个应用程序运行在它自己的Linux进程中。当应用程序中的任何代码需要执行时，Android将启动进程；当它不在需要和系统资源被其他应用程序请求时，Android将关闭进程。
每个应用程序都有他自己的Java虚拟机（VM），因此应用程序代码独立于其他所有应用程序的代码运行。
默认情况下，每个应用程序分配一个唯一的Linux用户的ID。权限设置为每个应用程序的文件仅对用户和应用程序本身可见——虽然也有一些方法可以暴露他们给其他应用程序。
有可能设置两个应用程序共享一个用户ID，这种情况下，他们能够看到对方的文件。为了节省系统资源，具有相同ID的应用程序也可以安排在同一个Linux进程中，共享同一个VM。
#### 2、应用程序组件
Android的一个主要特点是，一个应用程序可以利用其他应用程序的元素（假设这些应用程序允许的话）。例如，如果你的应用程序需要显示一个图像的滚动列表，且其他应用程序已经开发了一个合适的滚动条并可以提供给别的应用程序用，你可以调用这个滚动条来工作，而不用自己开发一个。你的应用程序不用并入其他应用程序的代码或链接到它。相反，当需求产生时它只是启动其他应用程序块。
对于这个工作，当应用程序的任何部分被请求时，系统必须能够启动一个应用程序的进程，并实例化该部分的Java对象。因此，不像其他大多数系统的应用程序，Android应用程序没有一个单一的入口点（例如，没有main()函数）。相反，系统能够实例化和运行需要几个必要的组件。有四种类型的组件：
```  
活动（Activities）
服务（Services）
广播接收者（Broadcast receivers）
内容提供者（Content providers）
```
然而，并不是所有的应用程序都必须包含上面的四个部分，你的应用程序可以由上面的一个或几个来组建。当你决定使用以上哪些组件来构建Android应用程序时，你应该将它们列在AndroidManifest.xml文件中，在这个文件中你可以声明应用程序组件以及它们的特性和要求。关于AndroidManifest.xml在Android开发之旅：HelloWorld项目的目录结构的1.6、AndroidManifest.xml简单介绍了一下，你可以参考一下，下篇也将介绍它。
#### 2.1、活动（Activities）
一个活动表示一个可视化的用户界面，关注一个用户从事的事件。例如，一个活动可能表示一个用户可选择的菜单项列表，或者可能显示照片连同它的标题。一个文本短信应用程序可能有一个活动，显示联系人的名单发送信息；第二个活动，写信息给选定的联系人；其他活动，重新查看旧信息或更改设置。虽然他们一起工作形成一个整体的用户界面，但是每个活动是独立于其他活动的。每一个都是作为Activity基类的一个子类的实现。
android.app.Activity类：因为几乎所有的活动（activities）都是与用户交互的，所以Activity类关注创建窗口，你可以用方法setContentView(View)将自己的UI放到里面。然而活动通常以全屏的方式展示给用户，也可以以浮动窗口或嵌入在另外一个活动中。有两个方法是几乎所有的Activity子类都实现的：
1) onCreate(Bundle)：初始化你的活动（Activity），比如完成一些图形的绘制。最重要的是，在这个方法里你通常将用布局资源（layout resource）调用setContentView(int)方法定义你的UI，和用findViewById(int)在你的UI中检索你需要编程地交互的小部件（widgets）。setContentView指定由哪个文件指定布局（main.xml），可以将这个界面显示出来，然后我们进行相关操作，我们的操作会被包装成为一个意图（Intent），然后这个意图对应有相关的activity进行处理。
2) onPause()：处理当离开你的活动时要做的事情。最重要的是，用户做的所有改变应该在这里提交（通常ContentProvider保存数据）。
一个应用程序可能只包含一个活动，或者像刚才提到的短信应用，它可能包含几个活动。这些活动是什么，以及有多少，当然这取决于它的应用和设计。一般来讲，当应用程序被启动时，被标记为第一个的活动应该展示给用户。从一个活动移动到另一个活动由当前的活动完成开始下一个。
每一个活动都有一个默认的窗口。一般来讲，窗口会填满整个屏幕，但是它可能比屏幕小或浮在其他窗口上。一个活动还可以使用额外的窗口——例如弹出式对话框，或当一用户选择屏幕上一个特定的项时一个窗口显示给用户重要的信息。
窗口的可视内容是由继承自View基类的一个分层的视图—对象提供。每个视图控件是窗口内的一个特定的矩形空间。父视图包含和组织子女视图的布局。叶子视图（在分层的底层）绘制的矩形直接控制和响应用户的操作。因此，一个视图是活动与用户交互发生的地方。例如，一个视图可能显示一个小的图片和当用户点击图片时发起一个行为。Android有一些现成的视图你可以使用，包括按钮（buttons）、文本域（text fields）、滚动条（scroll bars）、菜单项（menu items）、复选框（check boxes）等等。
通过Activity.setContentView() 方法放置一个视图层次在一个活动窗口中。内容视图（content view）是层次结构的根视图对象。层次结构如下图所示：
![img](P)  
Activity.setContentView() 方法：
public void setContentView (int layoutResID)：根据布局资源设置活动的界面。 资源将被夸大，添加布局资源文件中所有的最高层的视图（ top-level views ）到活动.
#### 2.2、 服务（Services）
一个服务没有一个可视化用户界面，而是在后台无期限地运行。例如一个服务可能是播放背景音乐而用户做其他一些事情，或者它可能从网络获取数据，或计算一些东西并提供结果给需要的活动（activities）。每个服务都继承自Service基类。
每个服务类在AndroidManifest.xml中有相应的<service>声明。服务可以通过Context.startService()和Context.bindService()启动。
一个典型的例子是一个媒体播放器播放一个播放列表中的歌曲。该播放器应用程序将可能有一个或多个活动（activities），允许用户选择歌曲和开始播放。然而，音乐播放本身不会被一个活动处理，因为用户希望保持音乐继续播放，当用户离开播放器去做其他事情时。为了保持音乐继续播放，媒体播放器活动可以启动一个服务运行在后台。系统将保持音乐播放服务运行，甚至媒体播放器离开屏幕时。
可以连接到（绑定到）一个持续运行的服务（并启动服务，如果它尚未运行）。连接之后，你可以通过服务暴露的接口与服务交流。对于音乐服务，这个接口可以允许用户暂停、倒带、停止和重新播放。
像活动（activities）和其他组件一样，服务（services）运行在应用程序进程中的主线程中。因此，他们将不会阻止其他组件或用户界面，他们往往产生其他一些耗时的任务（如音乐播放）。
#### 2.3、广播接收者（Broadcast receivers）
一个广播接收者是这样一个组件，它不做什么事，仅是接受广播公告并作出相应的反应。许多广播源自于系统代码，例如公告时区的改变、电池电量低、已采取图片、用户改变了语言偏好。应用程序也可以发起广播，例如为了他其他程序知道某些数据已经下载到设备且他们可以使用这些数据。
一个应用程序可以有任意数量的广播接收者去反应任何它认为重要的公告。所有的接受者继承自BroadcastReceiver基类。
#### BroadcastReceiver类：
是接受sendBroadcast()发送的意图（intents）的基类。可以用Context.registerReceiver()动态地注册这个类的实例，或者通过AndroidManifest.xml中<receiver>标签静态发布。注意：如果你在Activity.onResume() 注册一个接受者，你应该在Activity.onPause()注销它。因为当暂停时你不会收到意图，注销它将削减不必要的系统开销。不要在Activity.onSaveInstanceState()中注销它，因为它将不会被调用，如果用户移动到先前的堆栈。
有两种主要的可接受广播类型：
1) 正常广播（由Context.sendBroadcast发送）是完全异步的。所有的广播接收者以无序方式运行，往往在同一时间接收。这样效率较高，但是意味着接受者不能使用结果或终止广播数据传播。
2) 有序广播（由Context.sendOrderedBroadcast发送）一次传递给一个接收者。由于每个接收者依次执行，因此它可以传播到下一个接收器，也可以完全终止传播以便他不会传递给其他接收者。接收者的运行顺序可由匹配的意图过滤器（intent-filter）的android:priority属性控制。
广播接收者不显示一个用户界面。然而，它们启动一个活动去响应收到的信息，或者他们可能使用NotificationManager去通知用户。通知可以使用多种方式获得用户的注意——闪烁的背光、振动设备、播放声音等等。典型的是放在一个持久的图标在状态栏，用户可以打开获取信息。
#### 2.4、内容提供者（Content providers）
内容提供者（content provider）使一个应用程序的指定数据集提供给其他应用程序。这些数据可以存储在文件系统中、在一个SQLite数据库、或以任何其他合理的方式。内容提供者继承自ContentProvider 基类并实现了一个标准的方法集，使得其他应用程序可以检索和存储数据。然而，应用程序并不直接调用这些方法。相反，替代的是它们使用一个ContentResolver对象并调用它的方法。ContentResolver能与任何内容提供者通信，它与提供者合作来管理参与进来的进程间的通信。
内容提供者是Android应用程序的主要组成部分之一，提供内容给应用程序。他们封装数据且通过单个ContentResolver接口提供给应用程序。只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。如果你不需要在多个应用程序间共享数据，你可以直接使用SQLiteDataBase。
当ContentResolver发出一个请求时，系统检查给定的URI的权限并传递请求给内容提供者注册。内容提供者能理解URI想要的东西。UriMatcher 类用于帮组解析URIs。
需要实现的方法主要如下：
```  
query(Uri, String[], String, String[], String)  返回数据给调用者
insert(Uri, ContentValues) 插入数据到内容提供者
update(Uri, ContentValues, String, String[]) 更新内容提供者已存在的数据
delete(Uri, String, String[]) 从内容提供者中删除数据
getType(Uri) 返回内容提供者中的MIME 类型数据
```
更多的关于ContentResolver信息，请查看相关文档。
每当有一个应该由特定组件处理的请求，Android可以确保该组件的应用程序正在运行，如果没有就启动它，而且一个适当的组件实例可用，如果没有就创建。